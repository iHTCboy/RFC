组织：中国互动出版网（http://www.china-pub.com/）
RFC文档中文翻译计划（http://www.china-pub.com/compters/emook/aboutemook.htm）
E-mail：ouyang@china-pub.com
译者：马  良  （Blade_Satan  flikic@mail.ustc.edu.cn）
译文发布时间：2001-10-11
版权：本中文翻译文档版权归中国互动出版网所有。可以用于非商业用途自由转载，但必须
保留本文档的翻译及版权信息。


Network Working Group                                           H. Orman
Request for Comments: 2412                Department of Computer Science
Category: Informational                            University of Arizona
                                                           November 1998
                 
OAKLEY 键决定协议
(RFC2412--The OAKLEY Key Determination Protocol)

本备忘录的状态
本文档讲述了一种Internet社区的Internet标准跟踪协议，它需要进一步进行讨论和建
议以得到改进。请参考最新版的“Internet正式协议标准” (STD1)来获得本协议的标准化
程度和状态。本备忘录的发布不受任何限制。
版权声明
 Copyright (C) The Internet Society (1998).  All Rights Reserved.

摘要
       本文档描述了一种名为 OAKLEY的协议，即两个已经验证的部分在安全且加密
密_素材问题上取得一致。其基本的机理是Diffie-Hellman密_交换算法。

        OAKLEY协议支持完整转发安全性，用户通过定义抽象的群结构来使用
Diffie-Hellman算法，密_更新，及通过带外机制分发密_集，并且兼容用来管理SA
的ISAKMP协议。
目录
1．简介	3
2. 协议框架.	4
2.1概述.	4
2.2 符号	5
2.2.1 关于消息的描述.	5
2.2 符号指南.	5
2.3 交换密_消息概论	7
2.3.1 基本的密_交换消息域.	7
2.3.1.1 关于指数的建议	8
2.3.2  映向ISAKMP消息结构的映射.	8
2.4 密_交换协议.	9
2.4.1 一个攻击例子.	10
2.4.1.1 空值的域.	12
2.4.1.2 伪随机函数数字签名.	12
2.4.2 隐藏身份的攻击案例.	13
2.4.3 一个不使用Diffie-Hellman算法地私有身份地大胆例子.	15
2.4.3  一个保守的例子.	16
2.4.4  保护密_的额外强度.	17
2.5 身份与验证.	17
2.5.1 身份.	17
2.5.2 验证.	18
2.5.3确认验证密_.	19
2.5.4 获取身份对象.	19
2.6 加密变换的接口.	20
2.7重发,超时,与错误消息.	20
2.8 私有密_的附加安全措施:私有群.	21
2.8.1 定义一个新群.	22
2.8.2 使用一个私有群生成一个密_.	23
2.9 快速模式:从旧密_中生成新密_.	23
2.10 定义并使用预分配密_.	24
2.11 分配一个外部密_.	24
2.11.1 需要考虑的加密强度.	25
3.指定的生成安全联合.	25
4.ISAKMP的兼容性.	26
4.1 使用已存在的密_验证	26
4.2第三方验证.	26
4.3 新群模式.	27
5 安全实现注意事项.	27
6.OAKLEY解析与状态机.	27
7信任有效载荷.	29
附录A群描述符.	29
附录B消息格式.	33
附录C将一个可变精度整数编码.	33
附录D加密强度.	34
附录E著名的群.	34
E1. 著名的群1: 一个 768  比特素数.	35
E2. 著名的群2: 一个1024位素数.	36
E3. 著名的群3: 一个椭圆曲线群定义.	37
E4. 著名的群4: 一个大椭圆曲线群定义.	39
E5. 著名的群5: 一个1536位素数.	41
附录F实现群操作.	42
参考书目:	42

1．简介
         密_体制是依靠加密进行数据保护的核心，而且是[RFC2401]中描述的数据包保
护机制的基本组件，例如。一个可升级的安全的用于Internet密_分发机制是必要的。
该协议的目标是提供一种机制并且赋予其强大的加密强度。

         Diffie-Hellman密_交换算法提供了这样一种机制。它允许两个不同群体就一个共
享值达成一致而不需要加密。这个共享值可以立即用于紧接着的通信的加密。举例来说
    数据传送或是验证。STS协议[STS]提供了向一个安全协议中嵌入该算法的范例，一方
    除了可以确信安全的共享机密，双方还可以确信互相的身份，甚至当一个主动攻击者存
在时。
        因为OAKLEY是一种普通的密_交换协议，并且其生成的密_被用来加密的数据
的保密时间可能很长，20年或更长，所以协议中的算法能保证在保密期间密_的安全
性是很重要的，基于调研当代数学发展后的最乐观的预期性能。因此该协议有两种方式
来增加掌握了大量密_交换记录的攻击者（被动攻击者）攻击的困难，这些方式对于生
成用来加密的密_是很有用的。

        OAKLEY协议与STS协议是相关的，具有类似的鉴别Diffie-Hellman指数，并用
指数来决定一个共享密_，并且都达到了很好的转寄共享密_的安全性，但是它与STS
    协议有以下几点不同，

        首先是增加了弱地址确认机制。（“cookies",Phil Karn 在Photuris 密_交换协议
中所描述的）用来避免拒绝服务攻击。

        其次的扩充是允许两方共同为协议选取合适的支持算法：加密方法，密_产生方
法，验证方法。

第三点，验证并不依赖用于加密所用的Diffie-Hellman指数；相反，验证是通过
        将指数与各方的身份绑定来实现的。

协议不需要两方计算验证前的共享指数。

协议通过使用附加的算法加密增加了起源密_的安全性。用于加密的起源密_不仅
取决于Diffie-Hellman算法，还和用来安全验证通信双方的加密方法有关。

综上所述，协议清晰的定义了通信双方怎样才能选取数学结构（群的表示和操作）
来执Diffie-Hellman算法；用户可以使用标准的群组或是通过自己定义。用户定义
群组结构更进一步的保证了加密数据的长期数据的安全性。

OAKLEY有几种发布密_的方法。除了经典的Diffie-Hellman交换机制外，本协议
    可以基于一个已存在的密_产生一个新密_并且通过加密来发送一个表面上产生过的
密_.

        协议允许两方使用全部或部分纠错和优良的转寄安全特性.它也可用于基于对称加
密或非加密算法的验证功能.包含这样良好的适应性是为了让各方能便利选用用适合它
们自身安全和性能需求的特性.

        本文档从Karn,Simpson关于 Photuris work的工作进展汲取灵感(包括与作者的讨
论),特别要提及的Schertler eral 的关于ISAKMP的文档,以及ISAKMP协议的文档.还受
到了Paul van Oorschot ,Hugo krawcyzk 的论文的启迪.
 
2. 协议框架.
2.1概述.
        OAKLEY协议是用来为通信双方建立一个共享密_,通过分配一个标识符和联合经
过验证的身份信息.密_的名字可以被用来产生RFC2402,RFC2406协议中的安全联盟.
或是完成其它网络安全目标.

        每个密_被用于验证,加密,单向函数的算法组合起来.这些是OAKLEY的辅助算法
    它们在后来定义的由其它协议产生的安全联盟的出现既不必要也不禁止.

        关于怎样对于数据应用一个算法的细节的描述被称为变换.本文档中不包含变换的
定义,其定义可以在分散的RFC文档中找到.

    纠错记号,或者是"cookies",为双方提供一种较弱的源地址验证.cookie交换可以在在它执
行协议中复杂的运算(大整数求幂)之前完成.

        声明OAKLEY使用cookies的两个目的 :纠错和命名密_,是很重要的.参与协议的
双方每方都要拿出一个cookies来用于初始化密_;这样的cookies对成为密_的标识符
    (KEYID),一个可重复使用的密_素材.因为具有这样的双重角色,我们将用符号("COOKI 
E-I,COOKIE-R")来命名cookies串与标记"KEYID".可相互替换.

        OAKLEY是作为ISAKMP协议的一个组件来设计的,运行在UDP协议上,使用一个
众所周知的端口,(请查阅RFC中关于端口分配的部分,STDO2-RFC-1700).在技术上唯一
对协议环境的要求是底层协议栈必须能够提供每个消息的远程发送者的因特网地址.因
而,在理论上, OAKLEY可以直接应用于IP协议或是UDP协议之上,如果合适的话,则协
议以及端口分配都是可用的.

        运行OAKLEY的计算机必须提供一个随机数生成器,就像在[RANDOM]中描述的,
因为在该协议的描述中需要随机数资源.任何时候提及"当前"都意味着当前值是由随机
数生成器生成的,同样提及"伪随机"意味着相关的值是由伪随机生成器生成..

2.2 符号
      本节描述文档中用于消息顺序与目录的符号.
2.2.1 关于消息的描述.
        下面的协议交换是用一种简短的符号写成的,这种符号用清晰的方式来传达交换的
本质.下面简要介绍一下这种符号,关于格式及分配值的细节请参看附录.

        本文档中为了简洁的表示消息交换,使用了一种简短的符号来描述每个消息的源地
址,目的地址,以及相关的域.

        箭头("->")表示这消息是否从创始者发向响应者,反之则用("<-").

        消息中的域被命名并用逗号分隔开.该协议遵循惯例,即最先的几个域组成所有消息
的一个固定的头格式

        例如,假设一个包含固定格式消息的交换,四个固定域中两个是"cookies",第三个域
是消息的类型名,第四个域是用高精度的整数来表示的一个数的幂:

  Initiator                                       Responder
             ->    Cookie-I, 0, OK_KEYX, g^x                    ->
             <-    Cookie-R, Cookie-I, OK_KEYX, g^y             <-

        第一行符号表示了两个消息的次序.发起者在开始时发送一个带有四个域的消息给
响应者;其中第一个域包含未定义值"Cookies-I",第二个域包含数字零,第三个域代表
消息的类型为OK_KEYX,第四个域值为抽象群元素g的x次幂.

        第二行是响应者发向发起者的应答消息,第一个域值为"Cookie-R",第二个域
为"Cookie-I"值的一份拷贝,第三个域为的消息类型为OK_KEYX,第四个域为g的y次幂

        消息类型值OK_KEYX为大写代表它是一个唯一的常量.(常量在附录中有定义)

        可变精度的零长度整数在协议中是无效值.

        有时协议会指出一个完整的有效载荷是无效值(通常由密_来交换有效载荷).为了
简化分列,有效载荷仍会出现在消息中.

2.2 符号指南.
        Cookie-I与Cookies-R(或是CKY-I与CKY-R)是64位伪随机数.生成伪随机数的方
法必须保证在一个特定时期中代表每个远程IP地址的生成的伪随机数必须唯一.比如
说在小时内.

   KEYID是由发起者及响应者的cookies和说明域所组成的串.是密_素材名.

sKEYID用来指示由KEYID命名的密_素材,它从不被传送,但它将参与双方的各种
运算.

OK_KEYX与OK_NEWGRP 是截然不同的消息类型.

IDP位标志着在加密分界线后的数据被加密而 NIDP位则意味着没有加密.

        g^x与g^y是群元素编码后产生的结果,在关于群的描述中g是一个特殊的群元素
(参见附录A)且g^x意味着将g作x次幂.就如同在定义中所描述的,这种类型的编码将
产生一个可变精度的整数或是一对可变精度的整数.注意:我们将用g^xy作为g^(xy)的简
写.关于大整数的计算,各种不同的群定义以及基本的数学运算的参考资料请查阅附录F.
        
        EHA0是加密/散列/验证的一个选择列表.每一个选项包含一对值:一个类名及一个
算法名.

        EHAS是分别从EHA0列表中的加密/散列/验证三类中各选一个选项组成的三元集.

        GRP是群及其相关参数名(为32位值),参数包括:整数的大小,数学运算,生成元.现在
已有一些预定义的GRP(768位的….155位与210位的椭圆曲线,参阅附录E),在后续的协
议版本中还可以共享其它的群定义.区分概念GRP与群描述符是重要的,former是后者的
一个名字.
        
         竖线标志是用来表示位字符串的串连.域将被使用编码后的形式串联起来,就如同
出现在它们的有效载荷中的形式.

     Ni与Nr被发起者与响应者分别选取.
    
     ID(I) 和ID(R)分别被用来鉴别发起者与响应者的身份.
        
     E{x}Ki意味着使用发起者的公开密_来加密x,加密使用与验证方法组合在一起
算法,一般为RSA算法.

S{x}Ki意味着使用发起者的签名密_来对x签名.签名一般使用与验证组合在一
起的算法.一般为RSA算法,或是DSS算法.
  
prf(a,b)表示对数据b使用伪随机函数a.可以认为a作为一个键或一个值刻划了函
数prf;在后面的情形中它是一类函数的索引.其中每个函数都计算输入的散列或是单向
混合输出.

Prf(0,b)表示对数据b使用单向函数.

类似早先商讨过的表示一个单独算法的符号,例如,MD5,可以有两种用途.一.一个
键入式的MD5变换将用到一个密_"a",二.在单向函数中变换将有一个固定的密_
值"0".
        术语"变换"是指在相应的RFC中定义的函数,其中会提到"变换"是为了IPSEC中的
AH与ESP定义的(请参阅RFC2401.)
  
2.3 交换密_消息概论
        密_交换处理是一种确保双方公共密_信息状态安全的机制.相关的信息是一个密
_名,密_素材,双方的身份验证,并且有三种用于验证的算法:加密(用来保护双方的身
份),散列(一个用来保护消息及用来验证的消息域的伪随机函数),与验证(用于相互验证
的基本算法).在附录B中包含关于编码及`这些选项的含义.

        主交换模式有五种选择: 无状态cookie交换, 优秀的密_素材转寄安全性.身份的
保密, 优秀的保密身份转寄的安全性.使用数字签名(不可否认的),双方可以使用上述性
质的任意组合.

        处理的大致过程是这样的:首先交换的发起者在它的第一消息中声明它所想发出的
信息,响应者在应答中提供它所想提供的信息.交换过程一直持续下去直到双方的需求都
得到了满足为止.
        选择在每个消息中包含多少信息取决于选择了那个选项.例如: 如果不选无状态
cookie交换,不选身份的保密与优秀的保密身份转寄的安全性,选择了数字签名,这样的话
完成交换只需要三个消息.

         附加其它性质会增加决定密_素材的回合数.

         ISAKMP提供了域来指定使用AH与ESP协议的安全联合的参数.这些安全联合有
效载荷类型将由OAKLEY密_素材和算法来加密.但本文档不讨论如何这些内容.
          
2.3.1 基本的密_交换消息域.
        在一个OAKLEY密_交换消息中由12个域.并不是所有的域都与每个消息相关.
    如果一个域是不相关的可以置空值或是不出现(非有效载荷).
    CKY-I            发起者   cookie.
      CKY-R            响应者   cookie.
      MSGTYPE          用于密_交换, 可以是 ISA_KE&AUTH_REQ 或
                       ISA_KE&AUTH_REP; 对于每个新群组定义,
                       将是 ISA_NEW_GROUP_REQ 或 ISA_NEW_GROUP_REP
      GRP              用于交换的 Diffie-Hellman群名.
      g^x (or g^y)     表示群生成元幂的可变长度整数.
      EHAO or EHAS     加密,散列,验证函数分别被选择和提供.
      IDP              发起者是否使用g^xy加密随后信息(优秀的身份转寄安全性)
      ID(I)            发起者的身份.
      ID(R)            响应者的身份.
      Ni               由发起者提供的随机数
Nr               由响应者提供的随机数..
Cookies的这种结构导致执行并不是独立的.Phil Karn建议将它作为一个单向函数
对一个周期性更换的种子数值作用的结果,本地和远程的IP地址,本地与远程的UDP端
口.这样的话,cookies可以保持无状态与周期性的更换.但在OAKLEY中要注意,周期性
的更换种子数值也会导致由其生成的KEYID的也会变化,迫使消除与它有关的任何状态
信息.

为了支持预分配密_`,我们建议在cookie中为永久密_保留一些空间.上述的编
码依赖于本地实现. .

 凡是使用了OAKLEYS的加密函数必须时一种可以保证消息数据安全性与完整性的
加密变换.仅仅在加密块链接模式下使用DES算法是不允许的.可选的与必选的加密变
换将包含任何满足这个标准及在RFC240(ESP)中定义的安全性能.

 使用了OAKLEY的单向(散列)函数必须是一种可以用来做密_散列或是无密_的
加密变换.可选的与必选的加密变换将包含任何满足RFC2406(AH)中定义的安全性能.

 在实时环境下,其将是一个关于匹配交换中所用的GRP的强度的平均信息量的可
变精度整数.如果没有指出GRP,那么随机数长度最少为90比特,用于随机素材的伪随机
数生成器应该从长度至少90比特的初始化加密数据开始.参阅RFC 1750

2.3.1.1 关于指数的建议
        在理想情况下,用于密_交换的熵的指数至少要为180比特.这样可以保证在两次
交换中密_素材的绝对独立性(注意如果只有一方选择了随机指数的情况).在实际中,
实现者也许希望多个密_交换基于单独的一个关于180比特的熵值 ,与单向散列函数
来保证如果一个密_泄漏不会危及到其它密_.既然这样,将随机数与cookie的基值与
指数的基值分开,并且用180比特的熵来尽可能快的替换基值将是一个有效的方法.

        值0到P-1不能用来当作指数值,实现者要注意检查这些值,并且拒绝接受远程另外
一方发送来的值1到P-1.(P是用来定义一个有限群的素数)

2.3.2  映向ISAKMP消息结构的映射.
        所有的OAKLEY消息域都对应于ISAKMP消息有效载荷或有效载荷的组件.ISAKMP中
相关的有效载荷域,是SA有效载荷,AUTH有效载荷,授权有效载荷,密_交换有效载荷.
    当时,建立ISAKMP协议的框架是一项正在进行的工作,精确的将Oakley消息域映射到
ISAKMP有效载荷也是一项正在进行的工作.(从相关文档中可以获知).

在使用OAKLEY时,OAKMP的一些头部数据块与有效载荷域将为常数值.使用中的精
确值将在解决方案文档中附有的解释文档中发布.

以下将指出每个OAKLEY域将出现在那些ISAKMP消息结构中.解决方案对这种映射
有最终解释权.

CKY-I            ISAKMP header
      CKY-R            ISAKMP header
      MSGTYPE          Message Type in ISAKMP header
      GRP              SA payload, Proposal section
      g^x (or g^y)     Key Exchange Payload, encoded as a variable
                       precision integer
      EHAO and EHAS    SA payload, Proposal section
      IDP              A bit in the RESERVED field in the AUTH header
      ID(I)            AUTH payload, Identity field
ID(R)            AUTH payload, Identity field
      Ni               AUTH payload, Nonce Field
      Nr               AUTH payload, Nonce Field
      S{...}Kx         AUTH payload, Data Field
      prf{K,...}       AUTH payload, Data Field

2.4 密_交换协议.
      在OAKLEY密_交换中,精确的消息及数字交换取决于发起者与响应者使用了那些
选项.根据这些选项,一次密_交换可以用三个或更多的消息来完成.

      密_决定协议的三个组件是.

1.	cookie交换(可选,无状态)

2.	Diffe-Hellman 半密_交换.(可选,但为转寄安全的基本组成部分)


3.	验证(选项:ID的安全性,使用PFS的ID的安全性,不可否认)

        发起者可以提供尽可能少的信息,例如一个空交换,而不附带任何附加信息.另一方
      面,发起者也可以在开始时就提供响应者用于验证交换要求及快速完成密_决定所需
要的所有信息,前提条件时响应者也同意接受这种方法.如果响应者不接受这种方法,
      响应者可以只回复最小数量的信息.(最小限度,比如一个cookie)

         验证的方法可以是数字签名,公开密_,或一个带外对称密_.以上三种不同的方
法导致消息的微小变化,这些微小变化在本节的例子里有详细描述.

          如果协议没有按照正常方式中断,发起者有责任重发数据.因此在协议的连续通
信过程中,响应者必须避免抛弃应答信息直到得到发起者的认可.
      本节的剩余部分是一些例子,用来讲述怎样使用OAKLEY选项.

2.4.1 一个攻击例子.
         以下的例子是描述两方之间怎么样使用三个消息来完成一个密_交换.身份在这
里不是保密的,生成密_素材使用PFS来保护.

         通过使用数字签名,双方将产生一个通信校验,这个校验结果是可以被记录的,稍
后还可以提供给第三方.

         由群指数所蕴涵的密_素材对完成交换不是必需的.如果有必要推迟计算,执行者
可以保存"x"与"g^y"值并且标注密_素材为"不可计算的".稍后可以依据以上信息
继续计算.

  Initiator                                                   Responder
    ---------                                                   ---------
      -> CKY-I, 0,     OK_KEYX, GRP, g^x, EHAO, NIDP,               ->
        ID(I), ID(R), Ni, 0,
        S{ID(I) | ID(R) | Ni | 0 | GRP | g^x | 0 | EHAO}Ki
      <-  CKY-R, CKY-I, OK_KEYX, GRP, g^y, EHAS, NIDP,
        ID(R), ID(I), Nr, Ni,
        S{ID(R) | ID(I) | Nr | Ni | GRP | g^y | g^x | EHAS}Kr      <-
      -> CKY-I, CKY-R, OK_KEYX, GRP, g^x, EHAS, NIDP,               ->
     ID(I), ID(R), Ni, Nr,
          S{ID(I) | ID(R) | Ni | Nr | GRP | g^x | g^y | EHAS}Ki

        NB'NIDP"意味着PFS用来隐藏身份的选项是无效的.因此,在使用一个基于g^xy的
密_时,身份是是不用加密的.

        NB域在本文档中是用逗号分割开的;在真正的协议消息编码过程中是连接在一起
的,该编码过程在ISAKMP/Oakley解决方案中定义及描述.

        例子中的交换结果是一个密_的 KEYID=CKY-I|CKY-R与 值
         sKEYID=prf(NI|NR,g^xy|CKY-I|CKY-R).
         这次交换的大致处理过程如下:

     发起者
         发起者生成一个唯一的cookie,并将它与预期的响应者的IP绑定,并且它将选取
         状态信息如下:GRP(群组标识符),一个伪随机选择的指数x,g^x,EHAO表,随机
数,身份.在EHAO表中,首次的验证选择时一个支持数字签名的算法.并且用来验证
身份 随机数,及群的身份.发起者进一步指出该密_在无验证的初始化状态中,并
且为可能存在的重发与请求终止设置计时器.
         
         当想响应者收到这个消息.后,他可以选择忽略所有的信息,仅仅将它视为一个对
     cookie的请求,创建无状态.如果CKI-I并没有被IP头中的源地址使用,响应者生成一
     唯一的cookie,CKY-R.下一步就依赖于响应者的参数选择.最小的请求响应是将第一
     个cookie域设置为零,并且CKY-Y填在第二个域.为了举例,我们必须假定响应者具有
     攻击性(另一种情况见第六节),并且接受如下设定:

          首次验证选择(必须使用数字签名方法来验证初始化消息),
          对于发起者与响应者的身份缺乏足够的的转寄安全保护.

          在本例中响应者决定接受所有发起者提供的信息.并验证消息中的签名,并将其
      与(CKY-I,CKY-R)对及下列状态信息绑定:

          消息的网络源地址与目标地址
          无验证的密_状态.
          提供验证的首次算法.
          群组身份,本群组中的一个指数值'y',及消息中的g^x值.
          随机值Ni与一个伪随机选择值Nr.
          为可能的不正常状态设置的计时器.
          
        响应者通过回应消息计算g^y值,并同时使用私有密_ID(R)标记身份与随机数.
    并将消息发送给发起者.在所有的交换中,每一方将确信不接受1与g^(p-1)做为一个指
    数.
        本例中,响应者暗中接受的EHAO表验证类中的首次算法,这是因为响应者无法在
没有接收验证签名的算法的情况下确认发起者的数字签名.响应者的EHAS表也会反映
出他接受的信息.

  
  发起者接受到应答信息并且确认CKY-I是一个有效的网络地址与导入信息的联合.

    将CKY-R值加入到(CKY-I,网络地址)对的状态中.并且与所有(CKY-I,CKY-R)对的
状态信息绑定.
   
    通过状态信息来确认响应者的数字签名.(如果确认失败,消息被丢弃).
  
    将g^y加入到他的状态信息.
  
    将EHA选择保促到状态信息中.
    任意计算(g^y)^x=(g^x)^y(该计算可以延迟到发送应答消息).
    
    发送应答消息,使用公开密_ID(I)签名.
    
    标记密_身份(CKY-I|CKY-R)作为验证.并且组合应答消息和签名.
  
    当响应者接受发起者的消息,并且同时签名有效,它将标记密_为已验证状态.并将
 计算g^xy值并且将该值与密_身份绑定.

    请注意虽然用于身份保护的PFS并未使用,但用于生成密_素材的PFS仍然存在,
 因为Differ-Hellman的半密_g^x与g^y已经交换.

    即使响应者只接受部分发起者的信息,发起者仍然认为协议在处理过程中,发起者
 将假定没有被响应者接受的域信息也没有被响应者记录.

    如果响应者没有接受攻击性的交换,并且为A函数选择其它的一种算法,这时协议
 将不再继续使用来自于首次消息的数字签名算法或签名值.

2.4.1.1 空值的域.
    如果响应者不接受所有发起者提供的域,它将在响应的消息中对应的域里填入
NULL值.在第六节中有怎么用按从左至右的方式来选择域的指导方针.如果一个域不
被接受则这个域及其后面的所有域必须值NULL值.
      
    响应者将不记录一个域的任何信息,如果这个域不被接受的话.如果ID's与实
时状态也是NULL值话,经不会有一个基于这些NULL值的数字签名.

 2.4.1.2 伪随机函数数字签名.
    构造这个攻击性的例子是为了暗示虽然公开密_技术已应用于签名,然而.当
双方事先约定好计划与一个公用密_时,一个伪随机函数时可以使用的.

 如果在EHAO表中的第一个提议是一种"存在密_"方法时,则该提议中的密_
名用于签名的密_素材,该签名由与密_名绑定的H算法计算生成.
    
    假设EHAO表中的第一个提议为
         EXISTING-KEY, 32
         并且与密_身份32绑定的算法是MD5-HMAC,密_素材是一些比特串,称之为sK32
这时在攻击性交换的第一个消息中将显示签名:
S{ID(I), ID(R), Ni, 0, GRP, g^x, EHAO}Ki,并且签名的计算由函数:
MD5-HMAC_func(KEY=sK32, DATA = ID(I) | ID(R) | Ni | 0 | GRP | g^x
 | g^y | EHAO)
 来执行,( MD5-HMAC函数的精确定义请查阅相关的RFC文档)计算结果将出现在验证
有效载荷中.

2.4.2 隐藏身份的攻击案例.
         下列的例子指出在双方之间如何不使用数字签名来完成一次密_交换.在验证过
程中,公开密_加密算法隐藏了身份.群的指数交换并经过验证.但在交换过车中蕴涵的
密_素材(g^xy)是不需要的.

    这种方案与前面的数字签名方案有一个很重要的不同,那就是在第一个消息中,
响应者的身份以明文:ID(R')给出.然而, 公开密_算法隐藏的身份信息是与之不同的
ID(R).这所以这样是因为发起者必须通知响应者使用那对公开/私有密_对来解密.,但
同时,身份信息已被公开密_算法所隐藏.

    发起者也可以选择放弃对响应者身份的保密,但这样做是不合适的.相反,如果在
响应者的节点上有一个很著名的身份,则用于加密那个身份的公开密_算法就可以加密
真正的响应者身份.
    
Initiator                                                   Responder
   ---------                                                   ---------
     -> CKY-I, 0,     OK_KEYX, GRP, g^x, EHAO, NIDP,                ->
        ID(R'), E{ID(I), ID(R), E{Ni}Kr}Kr'
    <-  CKY-R, CKY-I, OK_KEYX, GRP, g^y, EHAS, NIDP,
        E{ID(R), ID(I), Nr}Ki,
        prf(Kir, ID(R) | ID(I) | GRP | g^y | g^x | EHAS) <-
     -> CKY-I, CKY-R, OK_KEYX, GRP, 0, 0, NIDP,
        prf(Kir, ID(I) | ID(R) | GRP | g^x | g^y | EHAS)    ->
      
      Kir = prf(0, Ni | Nr)

  NB "NIDP" 意味着隐藏身份的PFS选项没有使用.
  NB  ID(R')值包含在验证有效载荷中.(在附录B中有描述)

    交换的处理过程的大致轮廓如下:
     
发起者:
    发起者生成一个唯一的cookie并且将它与预期的响应者的IP地址绑定.并且选择
状态信息: GRP,g^x,EHAO列表.在EHAO列表中的第一个验证选择是一种算法,并且支持
公开密_算法.发起者还命名两个身份在连接中使用,并且将它们输入状态信息中.一个
众所周知的响应者身份也被选中.并且用于这个身份的公开密_用来加密随机数Ni
与两个连接用的身份,发起者更进一步说明密_处于初始化未经验证的状态,并且为可
能的重发与请求终止设置计时器.
     
    当响应者接受这个消息时,它可以选择忽略所有信息,并且仅仅以一个cookie请
求将其抛出,创建无状态.
     
    如果CKY-I还没有被源地址的IP头所使用,则响应者生成一个唯一的cookie,
CKY-R,如同以前,下一步取决于响应者的选择.最小的所需响应是一个将首个cookie
域设为零的消息,并且CKY-R在第二个域.在本例中,我们假设响应者更为大胆接受如下
设置:

    群GRP,第一个验证选择(必须为用于加密有效载荷的公开密_算法),缺乏可靠
身份信息的转寄安全性,身份ID(I),ID(R)
    
    响应者必须解密身份与随机数.使用R'的私有密_.然后,使用R的私有密_
来解密随机数.

    响应者现在可以绑定cookie对(CKY-I,CKY-R)与下列状态信息.
 
     消息的网络源地址及目标地址.
     密_的未验证状态.
     每一类的第一个算法在EHAO(加密散列验证算法)列表中
     群GRP与y和g^y值在群GRP中.
     随机数值Ni与伪随机值Nr.
     为可能的不正常状态设置的计时器.
    
响应者这时用ID(I)的公开密_加密状态信息,生成prf值,并将其发送给发起者.

   发起者收到回复消息并确认CKY-I是网络地址与此消息的一个有效绑定.

   将CKY-R值加入(CKY-I,网络地址)的状态信息中,并且将所有状态信息与(CKY-I,
CKY-R)绑定.

    解密身份信息与随机数..

    检查prf计算(如果失败,则丢弃该消息).

    将g^y加入状态信息中.

    在状态信息中保存EHA选择.

    计算(g^x)^y(=g^xy)(计算可能会被延迟).并且发送应答消息,使用ID(R)的公开
    密_加密,同时将KEYID(CKY-I|CKY-R)标记为已验证.
    
    当响应者收到这个消息时,密_已被标记为已验证状态.如果还没有这样做.它将计
    算g^xy并且将它与KEYID绑定.
      
    密_素材sKEYID=prf(Ni|Nr,g^xy| CKY-I|CKY-R)
   
    要指出的是,虽然用于身份保护的PFS没有使用,但用于保护密_素材的的PFS仍然
    存在,因为Diffie-Hellman 半密_g^x,g^y已交换.

2.4.3 一个不使用Diffie-Hellman算法地私有身份地大胆例子.

         如果任务中生成密_不需要优良转寄安全性,则可以避免消耗计算资源.双方可以
交换随机数与密_部分来完成验证任务与生成密_素材.使用生成密_素材来保护的
长期的加密数据的安全性,依赖于每一方使用的私有密_.
     在这个交换中,GRP为零值,群指数域则用来存放一个随机数值得替换.
  
在前面的章节中,首选的算法必须是一个公开密_加密系统.其响应为一个
cookie与一个非零指数域.响应者无疑议的接受首选算法,较差的关于身份及生成密
_素材的转寄安全性.

Initiator                                                   Responder
    ---------                                                   ---------
     -> CKY-I, 0,     OK_KEYX, 0, 0, EHAO, NIDP,                  ->
        ID(R'), E{ID(I), ID(R), sKi}Kr', Ni
     <-  CKY-R, CKY-I, OK_KEYX, 0, 0, EHAS, NIDP,
        E{ID(R), ID(I), sKr}Ki, Nr,
        prf(Kir, ID(R) | ID(I) | Nr | Ni | EHAS)                 <-
     -> CKY-I, CKY-R, OK_KEYX, EHAS, NIDP,
        prf(Kir, ID(I) | ID(R) | Ni | Nr | EHAS)                  ->

Kir = prf(0, sKi | sKr)

   NB  在随机状态域中的sKi与sKr值.符号的变化意味着强调他们的熵是设置密_素
材的临界值.
          
       NB "NIDP' 意味着用于隐藏身份的PFS选项没有使用.

         交换的结果是一个KEYID = CKY-I|CKY-R andvalue sKEYID = prf(Kir, CKY-I | 
CKY-R)的密_.

2.4.3  一个保守的例子.
            在本例中,双方都是很保守的态度.它们使用cookie交换来迟滞状态的创建.
并使
用优良的转寄安全来保护身份信息.所以在本例中,使用公开密_加密来验证.数字签
名,或预先共享的密_也被采用,如同在前面详细描述的那样.这个保守的例子不交换
随机数,prf's等等.但是它在传送的每个消息中交换多少信息呢?

    响应者认为发起者重复CKY-R的能力某种程度上说明消息来源于一个实时的处于
网络中的通讯者,并且这个通讯者与发起者的地网络地址绑定.发起者也有类似的假设
当CKY-I反复的发向发起者.
    
    所有的消息必须含有有效的cookies或者至少是一个零cookie.如果两个cookie
都是零,则意味着一个cookie请求.如果只是发起者的cookie为零,则是一个对
cookie请求的响应.

消息中的信息如果违反cookie规则,那么将降将不能用于任何的OAKLEY操作.

发起者与响应者必须就EHA算法的一个集合达成一致.不能发起者使用一个集合,
而响应着使用另一个算法集合.发起者在初始化时必须至少提供一个MD5或是DES算法

没有说明的域将填为空值.      
   
  Initiator                                                   Responder
      ---------                                                   ---------
        ->     0, 0, OK_KEYX                                          ->
        <-      0, CKY-R, OK_KEYX                                     <-
        ->     CKY-I, CKY-R, OK_KEYX, GRP, g^x, EHAO                  ->
        <-      CKY-R, CKY-I, OK_KEYX, GRP, g^y, EHAS                 <-
        ->     CKY-I, CKY-R, OK_KEYX, GRP, g^x, IDP*,
              ID(I), ID(R), E{Ni}Kr,                                 ->
        <-      CKY-R, CKY-I, OK_KEYX, GRP, 0  , 0, IDP,              <-
               E{Nr, Ni}Ki, ID(R), ID(I),
                prf(Kir, ID(R) | ID(I) | GRP | g^y | g^x | EHAS )
         ->     CKY-I, CKY-R, OK_KEYX, GRP, 0  , 0, IDP,
                prf(Kir, ID(I) | ID(R) | GRP | g^x | g^y | EHAS ) ->

   Kir = prf(0, Ni | Nr)

        *当IDP值有效时,验证有效载荷被所选的加密算法加密,算法使用的是密_素材
     prf(0,g^xy).(这个变换定义了加密算法将说明怎么样从密_素材中选取密_比特)
     这样的加密附加于任何公开密_的,请看附录B.

        在第一个消息中,几个域被忽略了,这些域目前都是空值.
   
        首次交换中允许响应者使用无状态cookies,如果响应者按照习惯生成cookies
    即允许在没有保存的情况下使他们生效,如同在Photuris中,则是可能的.甚至如果发
    起者,包含一个cookie在他的初始化请求中,响应者仍使用无状态cookies,仅仅从他的
    应答中忽略CKY-I,并且记录发起者的cookies直到 下一条消息出现.

        在交换完成以后,双方都要计算,共享密_素材sKEYID,prf(Ni| Nr, g^xy | CKY-I 
| CKY-R),prf是一个从EHA列表中散列类中选择的随机函数.
        
每一方都认为远程对方反复发送Ni或Nr值得能力作为一种证明.与远程方沟通,
    并确定远程方的身份.
        
         在分析本次交换中,需要注意虽然IDP选项确信身份是被一个暂时的密_g^xy保
    护,但要验证它自己不依赖于密_g^xy.通过有步骤地验证g^x,g^y值是基本的.从而可
以使验证不形成一个循环过程.第三方可以通过中间人代理的方式介入来使发起者与响
应者使用不同的g^xy值.虽然这样一个攻击,可能对窃听者的身份有所启发,但验证会
失败.
2.4.4  保护密_的额外强度.
         随机数Ni,Nr用来提供生成任务密_保密所需的额外的尺度.这样做使密_的安
全性依赖于两个不同问题:在群G中的离散对数问题,与破坏实时加密的方案问题.如果
    使用RSA来加密.则第二个问题大约等价于分解RSA的公开密_.
        
         为了验证,密_类型,确认方法,证明的需求都必须声明.
2.5 身份与验证.
2.5.1 身份.
               在OAKLEY交换中,发起者提供发起者与响应者的身份,这个模型首先要求
发起者的身份,然后是响应者的.

        如果没有指定任何一个身份,则身份将从IP包头部的源地址与目的地址提取.
     
        如果发起者没有提供一个身份,响应者可以使用本地策略允许的任一个身份应答.
     发起者可以通过终止交换来拒绝接受.

        响应者也可以使用不同于发起者所建议的身份来应答,发起者可以继续交换来默认
接受或是终止交换来拒绝接受.
2.5.2 验证.
       首先对另一方身份的验证是任何密_交换体系的核心.Internet通信必须产生一个
可以升级的标准来解决这个问题.OAKLEY必须遵循这个标准.在写本文档的同时,还没
有这样一个标准.虽然有了一些雏形.这个文档试图描述怎么样将已有的一些标准融入
OAKLEY协议中去.没有从中做挑选.

   下列方法可能出现在OAKLEY协议的实现中.

a.	预先共享密_.
当双方已经安排好了一个可靠的方法来分配密_用于验证他们互相的身份,他
们可以用来验证.在大的系统中这样做显然会使问题放大,但是它是一个可以接
受的限于某种情景下的临时方案.对于预共享密_的支持是需要的.

使用预共享密_的散列列以及验证算法必须作为状态信息的一部分随密_分
配.

预共享密_有一个KEYID,密_素材sKEYID,KEYID用于预共享密_验证选项实
现中,可能有不止一个预共享密_实现的方案在列表中.

因为KEYID持续存在于不同的OAKLEY启动情况.(在崩溃以后,等等),所以对于
双方来说它必须要占一个KEYID空间的保留部分.一些空间会在每个cookie空
间留出,以提供给它使用.
        没有在预共享密_方面的证明权威,当一个预共享密_用来生成验证有效载荷,不
存在证明权威.验证类型是'预共享',并且有效载荷还有KEYID,以64位来编码,应
用伪随机散列函数于消息体形成了这个函数的密_.

b.	DNS公开密_.

DNS的安全扩展机制(DNSSEC)提供了一种便利的途径来访问公开密_信息.特别
是公开密_与主机绑定时.RSA密_是实现DNS安全机制的必要条件.扩展至允
许选择DSS密_在近期可能实现.

DNS密_记录已经绑定签名记录,签名记录已被区域权威标记过.并且一个签名
的层级返回给已建立了信任基础的根服务器.SIG签名记录说明了用于形成签名
的算法.

OAKLEY协议的实现必须支持使用DNS密_与SIG签名记录用于验证关联的IPv4
,Ipv6以及全部的有资格的域名.然而,实现并不需要支持特定的算法(Rsa,DSS
等等).

c.	RSA公开密_权威证明签名PGP

[Zimmerman]通过不不正式的方法建立信任来使用公开密_.PGP公开密_的格
式与命名方法经在另一个RFC文档中描述.RSA算法可以用于PGP密_来签名或
是加密.验证选项将分别说明RSA-SIG,RSA-ENC.对它的支持是可选的.

        d.1  RSA公开密_证明有多种格式并且用于公开密_的命名惯例是被一个或多个
证明权威标记.公开密_互换协议讨论X.509编码与确认.对它的支持是可选
的

        d.2  DSS,密_证明编码用于数字签名标准X.509 draft-ietf-ipsec-dss-cert-
00.	txt.中有描述,对它的支持是可选的,一个ISAKMP验证类型将被分配.

2.5.3确认验证密_.

验证算法,授权证书,验证类型及一个密_(通常是公开的)的一个联合定义了怎么
样确认与已声明身份有关的消息.密_信息将接受来自一个预共享密_或是某种授权
证书的访问.
    
一般情况下,授权证书生成一个绑定公开密_实体名的证书.OAKLEY实现必须准
备好在使用用于OAKLEY验证目的的公开密_前,取得并确认证书.

ISAKMP验证有效载荷定义了验证授权域,用来指定必须出现在可信任的验证级别
的授权.

一旦获得适当地证书,选择那种确认方法将取决于验证类型.如果是PGP,则PGP签
名确认程序可以用来确保满足本地信任网的要求.如果是RSA X.509证书,证书必须
经过检验,检验授权证书的签名是否可以被确认,以及其级别是否已通过本地安全策的
检验.
    
2.5.4 获取身份对象.
         除了解释包含在身份中的证书或其它数据结构.OAKLEY协议的用户必须要面对重
新获取随身份中公开密_绑定的证书以及重新获取辅助证书用来确认授权或是源签名
者(如果在PGP信任网中的情况.

        ISAKMP信任有效载荷可以用来向OAELEY消息分配有用证书.信任有效载荷定义于
    附录B.

2.6 加密变换的接口.
       在密_交换后计算出的密_素材的熵至少为90比特,这样意味着它的长度至少为
    90比特.熵可以多些或少些以用来调节加密或是伪随机函数变换.

       随同OAKLEY协议使用的变换有辅助算法,辅助算法生成可变精度的证书并将它返回
    给适当长度的密_素材.例如,一个DES算法可以获得低56比特,三重的DES算法使用
   下列方法:
     
              K1 = low 56 bits of md5(0|sKEYID)
              K2 = low 56 bits of md5(1|sKEYID)
              K3 = low 56 bits of md5(2|sKEYID)
 
       密_素材调用的变换被编码为一个可变精度的整数,数据的长度,数据的存储块.
    密_素材至变换密_的转换时变换的职责.

2.7重发,超时,与错误消息.
          如果从响应者发回的应答没有在允许的时间内得到,则消息将会被发起者重发,
这些重发必须被双方优雅的处理;响应者必须保留重发的信息直到发起者移向协议中
      的下一个消息,或是完成交换.

          错误消息存在问题,原因在于他们不能仅仅用出现在未完成的交换中的信息来验
证.所以双方都希望为OAKLEY错误信息建立一个默认得密_.一个可行的方法建立一
个在附录B中描述的密_.是一红ISA_INIT 消息类型.
     
          如下的消息类型OAKLEY错误,KEYID使用H算法与验证消息内容的密_;这些值
可以由SIG/PRF有效载荷来携带.
      
        错误有效载荷包含错误码与拒绝消息的内容.

                       1                   2                   3
         0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        !                                                               !
        ~                       Initiator-Cookie                        ~
     /  !                                                               !
KEYID   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    \  !                                                               !
        ~                       Responder-Cookie                        ~
        !                                                               !
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        !                  Domain of Interpretation                     !
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        ! Message Type  ! Exch  ! Vers  !          Length               !
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        !                 SPI (unused)                                  !
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        !                 SPI (unused)                                  !
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        !                 Error Payload                                 !
        ~                                                               ~
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        !                 Sig/prf Payload
        ~                                                               ~
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

错误消息将包含出现在所提供消息的cookie,消息类型OAKLEY_ERROR,
出错原因,然后是拒绝消息.
错误消息仅仅用于报错,协议的正确性不依赖于他们.

   错误原因:

TIMEOUT                   交换时间过长,状态崩溃.
   AEH_ERROR                 出现在提议中的一种未知算法
   GROUP_NOT_SUPPORTED       不支持GRP命名
   EXPONENTIAL_UNACCEPTABLE  指数太大或太小或是1
   SELECTION_NOT_OFFERED     提议中没有选择项.
   NO_ACCEPTABLE_OFFERS      没有提议符合主机要求.
   AUTHENTICATION_FAILURE    签名或散列函数失败.
   RESOURCE_EXCEEDED         太多的交换或太多的状态信息.
   NO_EXCHANGE_IN_PROGRESS   接受到的应答没有进一步请求.

2.8 私有密_的附加安全措施:私有群.
如果双方需要使用Diffie-Hellman密_决定方案时,该方案不依赖于标准群的定义,
他们可以选择建立一个私有群.验证不需要重复,因为协议的这个阶段将被一个已存在
的密_保护.作为一个附加的安全措施,双方将建立一个私有名用来共享密_素材.甚至
他们使用同一个群来同其它方通信.这种重复使用对被动攻击者不是显然的.

   私有群又一种优势,通过增加必须很费力分析的群的数量来恢复大量的任务密_
这样做可以大大增加广泛分布的被动攻击者的攻击难度.这样就与只使用一个和两个
群形成对比,因为这个原因,所以可以认为年复一年的,任务密_的安全受到威胁.

   有两个技术上的挑战需要面对:一个特定的用户怎么样创建一个唯一的合适的群,与
第二方怎么样确认提议的群是相对可靠的.
  
一个幂模群的安全性取决于群大小的最大素数分解.为了使其最大化,可以采用足
够强壮的素数,或是Sophie Germaine素数.P=2Q+1,P与Q都为素数.然而P=kQ+1,k较
小的,群的强度还是相当大的.这些群像著名的Schnorr子群,发现它们比发现Sophie 
Germaine素数消耗的计算资源要少很多.

Schnorr子群通过使用近似素数测试可以被有效地确认.

相当容易就可以发现P,k,Q使得大素数因子可以很容易证实为Q

我们估计发现一个含有2~1024个元素的新群可能要用十分钟,并且可以按预定的
    程序一天进行一次;确认一个远程方提供的群大约使用1分钟,在一台25mHZ的RISC计
算机或是一台66MHZ的CISC计算机.

        我们声明确认只在已互相验证方之间展开,一个新群定义总是伴有一个密_,并被
该密_保护,该密_是用一个著名的群生成的.还有五点要牢记:

    A新群的描述与公开的身份被一个著名的群保护.

    B 响应者可以拒绝建立新群的企图,因为他太忙或是认为大素数因子不够充分的大.

    C 新的模与生成元可以被长期隐藏, 他们不处于安全状态,所以不参与正在进行的活动

    D 周期性的生成一个新的g^x值地代价是高昂的.例如果有很多隐藏的群,然而经常生
成新g^x值得重要性已经降低了,所以更换的周期时间可以相对的延长.

    E 所有的幂模群都有必主群弱的子群.例如Sophie Germain素数,如果生成元是一个平
方数,则在子群中就只有两个元素,1,g^(-1),(等价于g^(P-1))我们已经声明了要避
免使用的.例如Schnorr子群如果k不等于2,子群通过检验指数是否与1同余
(e^K!=1 mod P)可以被消除.

2.8.1 定义一个新群.
本节描述怎么样来定义一个新群.群的描述对于窃听者是隐藏的,双方对群的身份
分配是唯一的.在下一节中将讲述使用deffie-Hellman密_交换的新群.

描述的隐秘性及检验者的存在给被动攻击者带来了更大的困难.因为如果攻击者不
知道群的描述,将没有直接有效的途径获取使用群计算出的密_的相关信息.

   在这个交换中只有新群的描述需要加密,用该群来命名的OAKLEY任务将指出所需的
散列算法.加密时是使用的是OAKLEY任务中的加密函数.

    新群的描述将被编码进入新群的有效载荷中,随机数将被编进验证有效载荷中.
    加密边界外的数据将使用KEYID来命名的变换来加密.
下列消息使用ISAKMP密_交换OAKLEY新群标识符.

定义一个新的模指数群:

To define a new modular exponentiation group:

     Initiator                                        Responder
     ---------                                       ----------
      ->   KEYID,                                        ->
           INEWGRP,
           Desc(New Group), Na
           prf(sKEYID, Desc(New Group) | Na)

      <-   KEYID,
           INEWGRPRS,
           Na, Nb
           prf(sKEYID, Na | Nb | Desc(New Group))       <-

       ->  KEYID,
           INEWGRPACK
           prf(sKEYID, Nb | Na | Desc(New Group))        ->

   这些消息在加密边界使用提到过的密_来加密.散列值被放入数字签名域中(请查看
附录B).

     新群的标识符
      New GRP identifier = trunc16(Na) | trunc16(Nb)
    (turn16意味着截断至16比特.发起者与响应者必须使用与目前使用的GRPID's
有着不同上部数据的随机数.)
Desc(G) 是这个群描述的描述符地编码结果.
2.8.2 使用一个私有群生成一个密_.
一旦一个私有群被建立,他的群id可以被用在密_交换消息中的GRP位置.这个协
议在这里没有变化.
2.9 快速模式:从旧密_中生成新密_.
        当一个已经验证过的KEYID与联结的密_素材sKEYID已经存在,可以很容易的生成
另外的密_与KEYID's,他们共享一些类似的属性(GRP,EHA,等等)仅仅使用散列函数.
例如:KEYID可以是在主模式中生成的一员

  
  另一方面,已验证的密_可以是一个手工分配的密_,发起者与响应者经由
OAKLEY以外的手段共享它.如果这个方法已经为(CKY-I,CKY-R)生成了使用唯一值
得KEYID,那么这种方法是可以使用的.

接着,密_交换标识符是OAKLEY快速模式.验证有效载荷携带随机数,prf值由验证
有效载荷携带,验证授权是none类型是"预共享".

协议是:
The protocol is:

     Initiator                                           Responder
     ---------                                           ---------
     -> KEYID, INEWKRQ, Ni, prf(sKEYID, Ni)                ->
    <-  KEYID, INEWKRS, Nr, prf(sKEYID, 1 | Nr | Ni)      <-
     -> KEYID, INEWKRP, 0, prf(sKEYID,  0 | Ni | Nr)       ->

     The New KEYID, NKEYID, is Ni | Nr

     sNKEYID = prf(sKEYID, Ni | Nr )

身份,EHA值与NKEYID的绑定就像他们与KEYID绑定一样.

2.10 定义并使用预分配密_.
如果一个密_与一个绑定的密_标识符,状态信息已经由手工分配,则密_可以被
用于任何OAKLEY目的.这个密_必须与通常的状态信息:ID's,EHA算法绑定.

本地安全策略规定当一个手工密_在OAKLEY数据库中.例如,只有特权用户可以
访问与特权ID's绑定的密_.一个非特权用户只可以访问与他自己ID绑定的密_.

2.11 分配一个外部密_.
        一旦一个OAKLEY任务密_与辅助的算法建立起来之后,密_素材与H算法可以用来  
分配外部生成密_,并分配一个KEYID给他.

    如下,KEYID代表一个已经存在地,验证过的OAKLEY任务密_,sNEWKEYID代表一个 
外部生成的密_素材.

    密_交换标识符,是OAKLEY外部模式.密_交换有效载荷包含被保护的新密_.

Initiator                                                     Responder
  ---------                                                     ---------
  -> KEYID, IEXTKEY, Ni, prf(sKEYID, Ni)                               ->
  <-  KEYID, IEXTKEY, Nr, prf(sKEYID, 1 | Nr | Ni)                     <-
  -> KEYID, IEXTKEY, Kir xor sNEWKEYID*, prf(Kir, sNEWKEYID | Ni | Nr) ->

    Kir = prf(sKEYID, Ni | Nr)
*这个域由密_交换有效载荷携带.

每个部分在变换任何密_状态信息之前,必须使用KEYID状态中的H函数来确认散列值

响应者通过计算验证有效载荷中的Kir值得异或来恢复新密_.

新密_标识符,命名密_素材sNEWKEYID,是 prf(sKEYID, 1 | Ni | Nr).

要注意这个交换并无需要加密, Hugo Krawcyzk提出这个方法并说明它的优点.
2.11.1 需要考虑的加密强度.
        用来分配外部密_的密_的强度必须至少等价与外部密_的强度.一般的,这样意
味着sKEYID素材的长度必须大于或等sNEWKEYID素材的长度.

    外部密_的生成,它的强度,它特定的应用本协议中没有叙述;使用这个密_必须
使用一些其它方法来决定这些属性.

    在1996年初,90比特的加密强度必须使用2000比特的模指数群,128比特的加密强
度,必须使用3000比特的模指数群.
3.指定的生成安全联合.
         当一个安全联合定义后,只有KEYID需要给出,响应者将可以查看与KEYID绑定的
状态信息.并可以找到正确的密_素材,sKEYID.

     用于IPSEC协议如ESP,AH生成的密_是ISAKMP/Oakley解决方案文档的一个主题
 那个文档还描述了怎么样磋商可接受的参数集合与ESP,AH的标识符.以及怎么样精确
 计算密_素材用于每一个协议的实例.因为这定义的基本密_素材(g^xy),可以用来生
成用于几种ESP,AH实例的密_.使用单向函数将g^xy转换为几个唯一的密_的技巧
 是一种基本的正确用法.
4.ISAKMP的兼容性.
       OAKLEY使用ISAKMP头部与有效载荷格式,在附录B中有描述,比第四版的草案有明
显得扩展.
4.1 使用已存在的密_验证
       在各方都没有合适的公开密_机制用来验证对方的情况下,他们可以使用已经手工
分配过的密_.在建立了这些密_并与OAKLEY中的状态绑定后,他们可以用于验证依赖
    签名的验证模式,例如,野蛮模式.
        
       当一个已存在的密_出现在一个提议列表中时,它将由一个ISAKMP_EXISTING的验
证算法指出,这个值将在ISAKMP的RFC文档中被分配.

       当验证方法是ISAKMP_EXISTING,验证授权将有值ISAKMP_AUTH_EXISTING;这个域的
值必须在ISAKMP的RFC文档中定义过,并且不能与任何在IANA注册过的验证授权冲突.

        验证有效载荷将有两个部分:
     
        KEYID用于预存在的密_.

        用于被预存在密_验证的一方的标识符.

        对应KEYID的状态信息中的伪随机函数H将是签名算法,并且当生成或检测消息数
据的有效性的时候,它将使用对应密_(sKEYID)的密_素材.

     例如:
        如果已存在的密_有一个由KID指定的KEYID与128位的由sKID指定的密_素材.
  ,以及H算法命名的HMAC,则为一个数据块生成一个签名.HMAC(sKID,data)的输出将是相
  应的签名有效载荷.
        
        KEYID状态将有本地的及远程KEYID已被指定方的身份.它等于一个本地的安全策
略的实现,来决定何时可以用这样一个密_验证其它方.例如,一个已分配密_用于两台
    Internet主机A与B可以用来验证所有形如"alice@A,"bob@B "的身份.
4.2第三方验证.
       一个本地安全策略可以限制向信任方的密_流通.例如.运行在敏感标签相等的两台
机器上的OAKLEY守护进程.可能希望在与另一个具有相同敏感标签的用户的密_交换中成
为唯一的仲裁者.既然这样,就需要有某种途径获取密_交换的起源.也就是说,这两个守护
进程的身份将与一个密_绑定,并且这个密_将形成一个用于密_交换的签名
    
       签名有效载荷,在附录B中有叙述,就是用于这个目的的.这个有效载荷命名一个在
目前交换开始以前就存在地一个KEYID.用于这个KEYID的H算法用来计算一个完整性/
    验证值,为所有的前面所叙述的签名有效载荷计算.

       本地安全策略可以规定KEYID's适合于签名未来的交换.
4.3 新群模式.
             OAKLEY使用了一个新的KEI用于定义了一个新群的交换.
5 安全实现注意事项.
通过恢复DiffieHellman计算中使用的指数值得适时的攻击已由Paul Kocher描述.
见[Kocher].为了使这种攻击无效,实现时必须注意扰乱发出模指数的操作顺序.

  采用一个盲因子可以达成这个目标.一个群元素,x,随机的选取.当选定了一个元素
x同时计算出x^(-x)的值,这时,当计算(g^y)^x时,实现将按下列步骤计算"

           A = (rg^y)
           B = A^x = (rg^y)^x = (r^x)(g^(xy))
           C = B*r^(-x) = (r^x)(r^-(x))(g^(xy)) = g^(xy)

        只有当x使用超过100次的时候才有必要使用盲因子.(由Richard Schroeppe估算)
6.OAKLEY解析与状态机.
       有许多条状态路径通过OAKLEY,但他们都遵循从左向右的标准消息域序列模式.
   
      发起者按照如下的顺序决定一个初始化消息:
         
1.	提供一个cookie.这并不是必须得,但对于野蛮模式交换是有帮助的.

2.	选择一个群.具体选择一个著名的群还是选择一个私有群可以略过,
但在两个没有共同状态的OAKLEY守护进程之间的首次交换时一定要
选择一个著名的群(0,意味着没有群).要注意消息中使用的群的标识
符,而不是群的描述符.

3.	如果使用一个非空的群,它必须包含在EHAO中指定的第一个消息.在这
之前它不需要详细说明.

4.	提供加密,散列,验证列表.

5.	使用PFS来隐藏身份.
如果没有使用身份隐藏,则发起者有这个选项.

6.	命名这个身份并包含验证信息.
    
         在验证段的信息依赖于首次验证提议.在这个野蛮交换中,发起者希望响应者可以
接受所有的提议信息,与首次验证方法.验证方法决定了如下的验证有效载荷:

1.	签名方法. 签名将被用于所有的提议信息.

2.	一个公开密_加密方法.这个算法将被用来加密一个被请求的响应者的公开密
_身份中的随机值.有两种选择,取决于是否使用身份隐藏:

a.	不使用身份隐藏.ID's将以明文形式出现.
b.	使用身份隐藏.一个著名的ID,称为R',将以明文出现在验证有效载荷中.
将有两个ID's与一个随机数尾随其后,这些将用R'的公开密_加密.

3.	一个预存在密_方法.预存在密_将用来加密一个随机值.如果使用了身份隐藏,
则ID's将置于有效载荷中,使用绑定于预存在密_的E算法.

响应者可以接受所有的部分的或者完全不接受发起者的消息.

响应者接受了他想接受的所有域.使用与发起者相同的顺序.他可以在任何一步停止
   ,拒绝更进一步的域.(在他响应的消息中是空值.)最小的响应是一个cookie与GRP.

1.	接受cookie.响应者可以选择记录无状态信息直到发起者成功的使用响应者选用 
的cookie应答.如果成功,响应者使用一个cookie,GRP应答.

2.	接受GRP.如果群不被接受,响应者将不应答.响应者可以发送一个错误信息.指出
这个群不被接受.(模太小,未知的标识符.等等).注意" no group"在协议中有两
个不同含义.他可能意味着这个群没有说明.或者没有群可以使用(然而,PFS是不
可能的).
       
3.	接受g^x值.响应者声明他通过将他自己的g^y值包含在他的应答中来接受g^x 
值.他可以通过忽律g^x并在他的应答中赋予g^y值零长度来延迟这个过程.他
也可以发送一个错误消息拒绝g^x值
   
4.	接受每一个EHA列表中的一个元素,通过一个非零提议来说明接受.

5.	如果要求用PFS隐藏身份,则没有更进一步的数据跟随. 

6.	如果验证有效载荷存在,并且如果在提供的验证类中的第一个项目被接受,则响
应者必须确认/解密验证有效载荷以及签名有效载荷中的信息.响应者可以选取
一个随机值并使用与发起者相同的验证/散列算法来应答.

发起者要注意响应者已接受的信息.确认/解密的任何签名,散列,或者加密域并
且如果数据被接受,应答和响应者选择的EHA方法应该一致.发起者通过用于响应者的
cookie的非零值得存在使得他的应答与他初始化消息明显不同.

   签名或prf函数的输出将被编码为一个可变精度的整数见(附录C).KEYID将指出命
名密_素材与散列或者签名函数的KEYID.
7信任有效载荷.
       公开密_信息的证书可以与ISAKMP文档中定义的信任有效载荷中的OAKLEY消息
绑定.它将是著名的应用于信任状与身份的地设嫩保护选项.

安全考虑.

   本文档的主题就是安全,所以安全考虑在本文档中随处可见.


Author's Address

   Hilarie K. Orman
   Department of Computer Science
   University of Arizona

   EMail: ho@darpa.mil
     
附录A群描述符.

       OAKLEY中使用了三种截然不同的群表示法.每一个群使用它的群操作与表示群元
素的基本域来定义.这三种群表示法分别为,模指数群(称为MODP herein),基于有限域
GF[2^N]椭圆曲线群(称为EC2N herein),基于有限域GF[P]椭圆曲线群称为(ECP herein)
    对于每一种群的表示方法.根据选择的参数不同,有许多种实现方法都是可行的.

       有一些例外,所有的参数如果它们都是非负的多精度整数,使用本附录定义的地格式
发送(注意,要区别于附录C中的编码.).每个多精度的整数有一个前缀长度域,甚至在那
这个数据是多余的.

       对于EC2N类型的群来说,考虑参数为很多位的域才更加的合适,但是他们表示为一
多精度的整数,(正确的,带有长度域的).这是正常的编码方法.
   
       MODP意味着经典的模指数群,操作是计算G^x(mod P),使用数字参数P与G来定义
     群,.P必须是素数,G通常是2,但可以是一个更大的数字. 2 <=G<=P-2.

       ECP是一个椭圆曲线群,以素数P为模,这个定义等价于如下定义的群,Y^2=X^3+AX
    +B,群操作是乘以一个椭圆曲线点,这个群使用五个数字参数,素数P,两个曲线参数A与
B,与一个生成元(X,Y).A,B,X,Y都以P为模,而且必须是非负的小于P的整数.他们必须
    满足等价与以P为模的定义.

        EC2N是一个椭圆曲线群,基于有限群F[2^N].定义于如下的群等价.
    Y^2+XY=X^3+AX^2+B这个等式与上面的略有不同,它有XY项,AX^2项而不是AX项
    )
      
       我们必须说明表示域与椭圆曲线.这个域通过一个模2的N次不可约多项式来定义.
    如果使用U=2来对这个多项式求值,那么这个多项式以一个大小在2^N与2^(N+1)的整
数表示

        例如,这个域使用多项式U^155+U^62+1l来定义, 这个多项式可以表示成为
     2^155+2^62+1,来表示.这个群使用4各或者更多参数,A,B,X,Y.这些参数是GF[2^N]
    域的元素.可以认为多项式模2的次数小于N.如果多项式以U=2来求值例如,域元素
    U^2+1将表示为整数2^2+1,为5,两个参数A,B定义了曲线.A通常为零.B必须不为0.
    参数X,Y必须选择曲线上一点.参数ABXY必须满足定义的等式.以定义的多项式为
     模,模2.

  群描述符格式:

  群的类型: A  两字节群域.
           标识值为类型  'MODP','ECP','EC2N'将被定义(见ISAKMP-04).
           大小为一个域元素,这是最高限度(log2P)或者是不可约域多项式的次数:一个32
比特整数.
           素数P或者不可约域多项式:一个多精度整数.

    生成元: 一个或两个值,多精度整数.
    只适用于EC: 曲线参数: 两个值,多精度整数.

    下列参数是可选的(每一个都是独立的)

        一个零值可以用来当作一个空间占用者,来表示一个没有声明参数;任何从0到3的
        参数个数可以被发送.

        最大素数因子:这个编码值是群大小的LPF.一个多精度的整数.

    只适用于EC: 群的顺序:多精度整数.(MODP群的大小总是P-1).

     群的强度: 32位整数.
        群的强度很接近被保护的密_比特位数.
        它是由攻击强度的log2来决定的.
        随着我们对密码学的深入研究,它是可以改善的.

     这是一个经典模指数群的一般例子.
      群类型: "MODP"
      域元素的大小: log2(P)取整,一个32位整数.
      定义素数P;一个多精度的整数.
      生成元G:一个多精度的整数.2<=G<=P-2.
      
      可选项: 
      P-1的最大素因子: 一个多精度的整数Q.
      群的强度: 一个32位整数.我们将声明一个公式来计算这个值.(TBD).
 

     这是一个模P的椭圆曲线群的一般例子.
      群类型: "ECP"
      域元素的大小: log2(P)取整,一个32位整数.
      定义素数P;一个多精度的整数.
      生成元G:两个多精度的整数.每一个都<P.
      
      可选项: 
      P-1的最大素因子: 一个多精度的整数Q.
      群的强度: 一个32位整数.公式TBD.

这是一个特殊的椭圆曲线群的例子.

群类型: "EC2N"
不可约多项式的次数:155.
不可约多项式: U^155 + U^62 + 1,表示为多精度整数  2^155 + 2^62 + 1.
      生成元(X,Y):两个多精度的整数每一个都<2^155.
      对于我们的椭圆曲线,有123,与456,都表示为一个多精度整数.
      曲线参数AB:表示为两个多精度参数.每一个小于2^155.
      对于我们的椭圆曲线,有0与471951,都表示为两个多精度整数.
  
      可选项: 
      群顺序的最大素因子:
      3805993847215893016155463826195386266397436443
      表示为一个多精度整数.
      群的顺序:
      45671926166590716193865565914344635196769237316
      表示为一个多精度整数.

      群的强度:76, 一个32位整数


长度限制在16比特.. 

                          1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    !   Fixed value (TBD)           !             Length            !
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    .                                                               .
    .                  Integer                                      .
    .                                                               .
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


群描述符格式:
                          1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   !1!1!     Group Description     !             MODP              !
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   !1!0!        Field Size         !            Length             !
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   !                              MPI                              !
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   !1!0!          Prime            !            Length             !
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   !                              MPI                              !
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   !1!0!       Generator1          !            Length             !
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   !                              MPI                              !
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   !1!0!       Generator2          !            Length             !
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   !                              MPI                              !
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   !1!0!         Curve-p1          !            Length             !
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  !                              MPI                              !
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   !1!0!         Curve-p2          !            Length             !
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   !                              MPI                              !
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   !1!0!   Largest Prime Factor    !            Length             !
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   !                              MPI                              !
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
!1!0!      Order of Group       !            Length             !
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   !                              MPI                              !
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   !0!0!    Strength of Group      !            Length             !
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   !                              MPI                              !
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

附录B消息格式.

将Oakley消息编码为ISAKMP有效载荷说明将延期至ISAKMP/Oakley解决方案.

附录C将一个可变精度整数编码.

     可变精度整数将被编码为一个32比特长度域其后跟随着一个或者更多个32比特包括
  整数的表示,然后与第一个32比特中最重要的比特位排列起来.

                       1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      !    length                                                     !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      !    first value word (most significant bits)                   !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      !                                                               !
      ~     additional value words                                    ~
      !                                                               !
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

     一个上述编码方法的例子.用于重要的51比特位数.长度域指出2个32比特数量跟随
.数中最重要的非零比特是第一个32比特数量中的13位.低序比特位在第二个32比特数量.
 中.

                     1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       !                                                            1 0!
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       !0 0 0 0 0 0 0 0 0 0 0 0 0 1 x x x x x x x x x x x x x x x x x x!
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       !x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x!
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.
附录D加密强度.

       Diffie-Hellman算法用来计算用于对称算法的密_.破解Differ-Hellman算法并不比穷
    尽对称密_空间简单.最近,来自一个解密研究者组织[Blaze]的建议推荐采用一个75比
    特的对称密_以达到一个实用的安全级别.如果要保证20年内安全,那么他们建议使用
    90比特的密_.
        
       基于这个报告,OAKLEU用户的保守策略将是保证他们的Diffie-Hellman计算至少要
    相当于90比特的密_空间的安全性.为了在模指数群中完成这个任务,其中的最大素因
    子至少要有180比特.而且模数本身至少要有1400比特.在椭圆曲线群中,LPF至少要有
    180比特.

       如果加密密_的长期安全性不是问题,那么可以在模指数群中使用下列参数,
    150比特用于LPF,980比特用于模数.
   
       仅凭模数是不能决定Diffie-Hellman算法的强度的.在群中计算所用的指数的大小也
    是很重要的.指数的大小至少是从它自己生成的对称密_大小的两倍.我们建议ISAKMP
    实现使用至少180比特的指数(两倍于20年限的对称密_).

       以上估算的数学证明可以在估算解决离散对数问题的代价的文献中找到.这是一个
与分解大整数的数域筛法非常相关的任务,读者可以查阅[Stinson] ,[Schneier].

附录E著名的群.

  群的表示符:
  
      0   无群(用于占用空间与非DH交换)
      1   一个模数为768比特的模指数群.
      2   一个模数为1024比特的模指数群.
      3   一个模数为1536比特的模指数群.(TBD)
      4   基于 GF[2^155]的椭圆曲线群.
      5   基于 GF[2^185]的椭圆曲线群.

  
   值2^31以及更高的值用于私有群表示符.
 
   Richard Schroeppel完成了本附录的所有计算与数学工作.

经典的 Diffie-Hellman模指数群.
    
        选择用于群1与群2的素数具有确定的属性.64比特中的高位将被强行置为1.
这种措施有助于经典的余数算法,因为商数总可以处于被除数的高位.64比特中的低位
被置1,这样有利于Montgomery风格的余数算法.因为乘数总可以处于被除数的低位.
中间位从Pi地二进制码中选取.这样可以保证随机性.从而避免了关于素数选取得安全
被消弱的猜疑.

   两个素数都基于PI,所以在两个素数的十六进制表示中有一大段重叠.选取得素数是
Sophie Germain素数.(也就是说(P-1)/2也是一个素数).具有了对抗平方根攻击的的最大
强度.
 
   检验数从开始时就会不断地以2~64递增,直到合适的素数被发现.

   因为这两个素数都等于7 (mod 8),所以2是每一个素数的二次剩余值.所有2的幂也
将都是二次剩余.这样可以预防通过学习Diffie-Hellman指数的低位来攻击的对手.
(AKA子群限制问题.)对于某些模指数算法使用两个生成元是很有效的.[注意,2是学术
上的而不是一个数论中的生成元.因为它忽略可可能的另一半模P的剩余.从密码学的
角度来看,这是一个优点.

E1. 著名的群1: 一个 768  比特素数.

   素数是2^768 - 2^704 - 1 + 2^64 * { [2^638 pi] + 149686 }.
   十进制是
     155251809230070893513091813125848175563133404943451431320235
     119490296623994910210725866945387659164244291000768028886422
          915080371891804634263272761303128298374438082089019628850917
          0691316593175367469551763119843371637221007210577919

已经被严格的证明为素数.

OAKLEY中的群表示为
群类型:         "MODP"
      域元素的大小(比特): 768
      素数模;            21(十进制)
      长度(32比特):      24
      数据(十六进制):
      FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1
      29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD
      EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245
      E485B576 625E7EC6 F44C42E9 A63A3620 FFFFFFFF FFFFFFFF

      生成元: 22 (十进制)
     
      可选项: 
      群顺序的最大素因子:   24(十进制)
      长度(32比特):         24
      数据(十六进制):
          7FFFFFFF FFFFFFFF E487ED51 10B4611A 62633145 C06E0E68
          94812704 4533E63A 0105DF53 1D89CD91 28A5043C C71A026E
          F7CA8CD9 E69D218D 98158536 F92F8A1B A7F09AB6 B6A8E122
          F242DABB 312F3F63 7A262174 D31D1B10 7FFFFFFF FFFFFFFF

 群的强度:                    26 (十进制).
    长度(32比特)              1
    数据(十六进制):
             00000042

E2. 著名的群2: 一个1024位素数.
    
素数是2^1024 - 2^960 - 1 + 2^64 * { [2^894 pi] + 129093 }.

    十进制是
    179769313486231590770839156793787453197860296048756011706444
    423684197180216158519368947833795864925541502180565485980503
    646440548199239100050792877003355816639229553136239076508735
    759914822574862575007425302077447712589550957937778424442426
    617334727629299387668709205606050270810842907692932019128194
    467627007


已经被严格的证明为素数.

OAKLEY中的群表示为
群类型:         "MODP"
      域元素的大小(比特):   1024
      素数模;            21(十进制)
      长度(32比特):      32
      数据(十六进制):
FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1
            29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD
            EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245
            E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7ED
            EE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE65381
            FFFFFFFF FFFFFFFF


      生成元:        22 (十进制)
        长度(32比特)   1 
        数据(十六进制)  2

      可选项: 
      群顺序的最大素因子:   24(十进制)
      长度(32比特):         32
      数据(十六进制):
            7FFFFFFF FFFFFFFF E487ED51 10B4611A 62633145 C06E0E68
            94812704 4533E63A 0105DF53 1D89CD91 28A5043C C71A026E
            F7CA8CD9 E69D218D 98158536 F92F8A1B A7F09AB6 B6A8E122
            F242DABB 312F3F63 7A262174 D31BF6B5 85FFAE5B 7A035BF6
            F71C35FD AD44CFD2 D74F9208 BE258FF3 24943328 F67329C0
            FFFFFFFF FFFFFFFF


 群的强度:                    26 (十进制).
    长度(32比特)              1
    数据(十六进制):
             0000004D

E3. 著名的群3: 一个椭圆曲线群定义.
    曲线是基于Galois域GF[2^155].有2^155个元素.这个域的不可约多项式是
u^155 + u^62 +1
椭圆曲线的方程是: Y^2 + X Y = X^3 + A X + B
X, Y, A, B是域中的元素.

对于说明过的曲线, A=0,
B= u^18 + u^17 + u^16 + u^13 + u^12 + u^9 + u^8 + u^7 + u^3 + u^2 + u + 1.

B的二进制表示为1110011001110001111 十进制为471951,十六进制为7338F.

生成元是曲线上的点(X,Y)

X = u^6 + u^5 + u^4 + u^3 + u + 1

Y = u^8 + u^7 + u^6 + u^3.
    
X二进制表示为1111011十进制为123.

Y二进制表示为111001000十进制为456.

群顺序为
45671926166590716193865565914344635196769237316

是下面素数的12倍.
3805993847215893016155463826195386266397436443.
已经被严格的证明为素数.
这个生成点(X,Y)的序数是素数的4倍,而生成元是一些曲线点的3倍

这个群的OAKLEY表示.

群类型:                                 "EC2N"
域元素的大小(比特):                     155.
不可约多项式:                          21(十进制)
         长度(32比特):                       5
         数据(十六进制):
          08000000 00000000 00000000 40000000 00000001
生成元:
 X坐标:                               22 (十进制)
        长度(32比特)                         1
        数据(十六进制)                        7B
       
  Y坐标:                               22 (十进制)
        长度(32比特)                         1
        数据(十六进制)                        1C8

椭圆曲线参数:
 A参数:                                 23 (十进制)
        长度(32比特)                         1
        数据(十六进制)                        0
B参数:                                 23 (十进制)
        长度(32比特)                         1
        数据(十六进制)                        7338F

      可选项: 
最大群序数素因子:                           24 (十进制)
        长度(32比特):                          5
        数据(十六进制):
        00AAAAAA AAAAAAAA AAAAB1FC F1E206F4 21A3EA1B  

群序数:                                   25 (十进制)
        长度(32比特):                          5
        数据(十六进制):
        08000000 00000000 000057DB 56985371 93AEF944
     
  群强度.                                   26 (十进制)
        长度(32比特):                           1
        数据(十六进制):
           0000004C

E4. 著名的群4: 一个大椭圆曲线群定义.
曲线是基于Galois域GF[2^185].有2^185个元素.这个域的不可约多项式是
        u^185 + u^69 + 1.
  椭圆曲线的方程是:   Y^2 + X Y = X^3 + A X + B.
X, Y, A, B是域中的元素.

对于说明过的曲线, A=0,
B= u^12 + u^11 + u^10 + u^9 + u^7 + u^6 + u^5 + u^3 + 1.


B的二进制表示为1111011101001十进制为7913,十六进制为1EE9.

生成元是曲线上的点(X,Y)

X = u^4 + u^3 

Y = u^3 + u^2 + 1.

X二进制表示为11000十进制为24

Y二进制表示为1101十进制为13

群顺序为
49039857307708443467467104857652682248052385001045053116,
是下面素数的4倍
3805993847215893016155463826195386266397436443.
已经被严格的证明为素数.
这个生成点(X,Y)的序数是素数的2,而生成元是一些曲线点的2倍

这个群的OAKLEY表示.
群类型:                                 "EC2N"
域元素的大小(比特):                     185.
不可约多项式:                          21(十进制)
         长度(32比特):                       6
         数据(十六进制):
          02000000 00000000 00000000 00000020 00000000 00000001
生成元:
 X坐标:                               22 (十进制)
        长度(32比特)                         1
        数据(十六进制)                        18
       
  Y坐标:                               22 (十进制)
        长度(32比特)                         1
        数据(十六进制)                        D

椭圆曲线参数:
 A参数:                                 23 (十进制)
        长度(32比特)                         1
        数据(十六进制)                        0

 B参数:                                 23 (十进制)
        长度(32比特)                         1
        数据(十六进制)                       1EE9

      可选项: 
最大群序数素因子:                           24 (十进制)
        长度(32比特):                          6
        数据(十六进制):
        007FFFFF FFFFFFFF FFFFFFFF F6FCBE22 6DCF9210 5D7E53AF  

群序数:                                   25 (十进制)
        长度(32比特):                          6
        数据(十六进制):
        01FFFFFF FFFFFFFF FFFFFFFF DBF2F889 B73E4841 75F94EBC
     
  群强度.                                   26 (十进制)
        长度(32比特):                           1
        数据(十六进制):
             0000005B

E5. 著名的群5: 一个1536位素数.
    
素数是2^1536 - 2^1472 - 1 + 2^64 * { [2^1406 pi] +  741804

    十进制是
            241031242692103258855207602219756607485695054850245994265411
            694195810883168261222889009385826134161467322714147790401219
            650364895705058263194273070680500922306273474534107340669624
            601458936165977404102716924945320037872943417032584377865919
            814376319377685986952408894019557734611984354530154704374720
            774996976375008430892633929555996888245787241299381012913029
            459299994792636526405928464720973038494721168143446471443848
            8520940127459844288859336526896320919633919

已经被严格的证明为素数.

OAKLEY中的群表示为
群类型:         "MODP"
      域元素的大小(比特):   1536
      素数模;            21(十进制)
      长度(32比特):      48
      数据(十六进制):
FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1
               29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD
               EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245
               E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7ED
               EE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE45B3D
               C2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8 FD24CF5F
               83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D
               670C354E 4ABC9804 F1746C08 CA237327 FFFFFFFF FFFFFFFF


      生成元:        22 (十进制)
        长度(32比特)   1 
        数据(十六进制)  2

可选项: 
      群顺序的最大素因子:   24(十进制)
      长度(32比特):         48
      数据(十六进制):
            7FFFFFFF FFFFFFFF E487ED51 10B4611A 62633145 C06E0E68
            94812704 4533E63A 0105DF53 1D89CD91 28A5043C C71A026E

F7CA8CD9 E69D218D 98158536 F92F8A1B A7F09AB6 B6A8E122
               F242DABB 312F3F63 7A262174 D31BF6B5 85FFAE5B 7A035BF6
               F71C35FD AD44CFD2 D74F9208 BE258FF3 24943328 F6722D9E
               E1003E5C 50B1DF82 CC6D241B 0E2AE9CD 348B1FD4 7E9267AF
               C1B2AE91 EE51D6CB 0E3179AB 1042A95D CF6A9483 B84B4B36
               B3861AA7 255E4C02 78BA3604 6511B993 FFFFFFFF FFFFFFFF


 群的强度:                    26 (十进制).
    长度(32比特)              1
    数据(十六进制):
              0000005B

附录F实现群操作.
      
       群操作顺序必须按照算术法则顺序实现;准确的群操作依赖于群.对于模指数群来说
    操作是多精度的整数乘法与按照群的模取余数.关于讨论怎么样对大整数实现这些操作
见Knuth Vol. 2 [Knuth].关于基于GF[2^N]椭圆曲线群操作的实现建议见[Schroeppel]..

参考书目:
        
  [RFC2401]    Atkinson, R., "Security Architecture for the
                Internet Protocol", RFC 2401, November 1998.

   [RFC2406]    Atkinson, R., "IP Encapsulating Security Payload (ESP)",
                RFC 2406, November 1998.

   [RFC2402]    Atkinson, R., "IP Authentication Header", RFC 2402,
                November 1998.

   [Blaze]      Blaze, Matt et al., MINIMAL KEY LENGTHS FOR SYMMETRIC
                CIPHERS TO PROVIDE ADEQUATE COMMERCIAL SECURITY. A
                REPORT BY AN AD HOC GROUP OF CRYPTOGRAPHERS AND COMPUTER
                SCIENTISTS...  --
                http://www.bsa.org/policy/encryption/cryptographers.html

   [STS]        W. Diffie, P.C. Van Oorschot, and M.J. Wiener,
                "Authentication and Authenticated Key Exchanges," in
                Designs, Codes and Cryptography, Kluwer Academic
                Publishers, 1992, pp. 107

   [SECDNS]     Eastlake, D. and C. Kaufman, "Domain Name System
                Security Extensions", RFC 2065, January 1997.

   [Random]     Eastlake, D., Crocker, S. and J. Schiller, "Randomness
                Recommendations for Security", RFC 1750, December 1994.

   [Kocher]     Kocher, Paul, Timing Attack,
                http://www.cryptography.com/timingattack.old/timingattack.html

   [Knuth]      Knuth, Donald E., The Art of Computer Programming, Vol.
                2, Seminumerical Algorithms, Addison Wesley, 1969.

   [Krawcyzk]   Krawcyzk, Hugo, SKEME: A Versatile Secure Key Exchange
                Mechanism for Internet, ISOC Secure Networks and
                Distributed Systems Symposium, San Diego, 1996

   [Schneier]   Schneier, Bruce, Applied cryptography: protocols,
                algorithms, and source code in C, Second edition, John
                Wiley & Sons, Inc. 1995, ISBN 0-471-12845-7, hardcover.
                ISBN 0-471-11709-9, softcover.

   [Schroeppel] Schroeppel, Richard, et al.; Fast Key Exchange with
                Elliptic Curve Systems, Crypto '95, Santa Barbara, 1995.
                Available on-line as
                ftp://ftp.cs.arizona.edu/reports/1995/TR95-03.ps (and
                .Z).

   [Stinson]    Stinson, Douglas, Cryptography Theory and Practice. CRC
                Press, Inc., 2000, Corporate Blvd., Boca Raton, FL,
                33431-9868, ISBN 0-8493-8521-0, 1995

   [Zimmerman]  Philip Zimmermann, The Official Pgp User's Guide,
                Published by MIT Press Trade, Publication date: June
                1995, ISBN: 0262740176

Full Copyright Statement

   Copyright (C) The Internet Society (1998).  All Rights Reserved.

   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implementation may be prepared, copied, published
   and distributed, in whole or in part, without restriction of any
   kind, provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing
   the copyright notice or references to the Internet Society or other
   Internet organizations, except as needed for the purpose of
   developing Internet standards in which case the procedures for
   copyrights defined in the Internet Standards process must be
   followed, or as required to translate it into languages other than
   English.

   The limited permissions granted above are perpetual and will not be
   revoked by the Internet Society or its successors or assigns.

   This document and the information contained herein is provided on an
   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

RFC2412--The OAKLEY Key Determination Protocol               OAKLEY 键决定协议 


1
RFC文档中文翻译计划
